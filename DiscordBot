import discord
import asyncio
import requests
from discord.ext import tasks, commands
from dotenv import load_dotenv
import os
import subprocess
import sys

# Load environment variables
load_dotenv(r"path_to_file_env")

# Configuration
TOKEN = os.getenv("DISCORD_TOKEN")
GUILD_ID = os.getenv("GUILD_ID")
CHANNEL_ID = os.getenv("CHANNEL_ID")
YOUTUBE_CHANNEL_ID = os.getenv("YOUTUBE_CHANNEL_ID")
YOUTUBE_CHANNEL_NOTIFICATION_ID = os.getenv("YOUTUBE_CHANNEL_NOTIFICATION_ID")
ROLE_ID = os.getenv("ROLE_ID")
TWITCH_USERNAME = os.getenv("TWITCH_USERNAME")
TWITCH_CLIENT_ID = os.getenv("TWITCH_CLIENT_ID")
TWITCH_ACCESS_TOKEN = os.getenv("TWITCH_ACCESS_TOKEN")
TWITCH_API_URL = f"https://api.twitch.tv/helix/streams?user_login={TWITCH_USERNAME}"

YOUTUBE_API_KEY = os.getenv("YOUTUBE_API_KEY")
YOUTUBE_API_URL = f"https://www.googleapis.com/youtube/v3/search?part=snippet&channelId={YOUTUBE_CHANNEL_ID}&order=date&maxResults=1&key={YOUTUBE_API_KEY}"

intents = discord.Intents.default()
intents.message_content = True
intents.guilds = True
client = commands.Bot(command_prefix="!", intents=intents)

global last_status, message_id
last_status = False  # Track previous stream status
last_video_id = None  # Track the last posted video ID
message_id = None  # Track the message ID for deletion

async def send_live_notification(channel, role, game, title):
    return await channel.send(f"{role.mention} Knuckleykong is now LIVE on Twitch! Playing {game} - {title}. Check it out: https://www.twitch.tv/{TWITCH_USERNAME}")

async def delete_notification(channel, message_id):
    try:
        message = await channel.fetch_message(message_id)
        await message.delete()
    except Exception as e:
        print(f"Failed to delete message: {e}")

def check_twitch_status():
    headers = {
        "Client-ID": TWITCH_CLIENT_ID,
        "Authorization": f"Bearer {TWITCH_ACCESS_TOKEN}"
    }
    response = requests.get(TWITCH_API_URL, headers=headers)
    if response.status_code == 200:
        data = response.json()
        if len(data.get("data", [])) > 0:
            stream = data["data"][0]
            return True, stream.get("game_name"), stream.get("title")
    return False, None, None

async def check_youtube_video():
    # Fetch the latest YouTube video using the YouTube API
    response = requests.get(YOUTUBE_API_URL)
    if response.status_code == 200:
        data = response.json()
        items = data.get("items", [])
        if items:
            video = items[0]
            video_title = video["snippet"]["title"]
            video_url = f"https://www.youtube.com/watch?v={video['id']['videoId']}"
            return video_title, video_url
    return None, None

@tasks.loop(seconds=15)
async def check_stream_status():
    global last_status, message_id
    is_live, game, title = check_twitch_status()
    guild = client.get_guild(int(GUILD_ID))
    channel = guild.get_channel(int(CHANNEL_ID))
    role = guild.get_role(int(ROLE_ID))

    if is_live and not last_status:
        message = await send_live_notification(channel, role, game, title)
        message_id = message.id
        print("Sent live notification.")
    elif not is_live and last_status and message_id:
        await delete_notification(channel, message_id)
        message_id = None
        print("Deleted offline notification.")

    last_status = is_live

@tasks.loop(minutes=720)
async def check_youtube_video_task():
    video_title, video_url = await check_youtube_video()  # Await the YouTube video check
    if video_title and video_url:
        guild = client.get_guild(int(GUILD_ID))
        channel = guild.get_channel(int(YOUTUBE_CHANNEL_NOTIFICATION_ID))
        role = guild.get_role(int(ROLE_ID))
        if channel and role:
            await channel.send(f"{role.mention} Latest Yeti Report: {video_title} - {video_url}")
            print(f"Sent YouTube video notification: {video_title}")

@client.event
async def on_ready():
    print(f'Logged in as {client.user}')
    for guild in client.guilds:
        await client.tree.sync(guild=guild)
    print("Slash commands synced.")
    check_stream_status.start()

@client.tree.command(name="ping")
async def ping(interaction: discord.Interaction):
    latency = client.latency * 1000  # Convert latency to milliseconds
    await interaction.response.send_message(f"Pong! Latency: {latency:.2f}ms")

@client.tree.command(name="status")
async def status(interaction: discord.Interaction):
    status_msg = "Live" if last_status else "Offline"
    await interaction.response.send_message(f"Knuckleykong is currently: {status_msg}")

@client.tree.command(name="restart")
async def restart(interaction: discord.Interaction):
    await interaction.response.send_message("Restarting bot...")
    subprocess.Popen([sys.executable, __file__])  # Restart the bot
    await client.close()  # Close the current bot instance


client.run(TOKEN)
